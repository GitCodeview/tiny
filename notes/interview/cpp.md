[TOC]



# 面试相关：

### 语言基础

C++中的定义，指针，模板，**多态**，重载等

1. **C和C++的区别？**

   C是面向过程的语言，C++是面向对象的语言

   C++中new和delete是对内存分配的运算符，取代了C中的malloc和free

   C++中有引用的概念，C中没有

   C++引入了类的概念，C中没有

   C++有函数重载，C中不能

   C变量只能在函数的开头处声明和定义，而C++随时定义随时使用

2. **指针与引用的区别**

   如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；（为什么？？）

   - 指针保存的是指向对象的地址，引用相当于变量的别名，可以将引用看做是操作受限的指针
   - 指针是变量，存储的是地址，指针可以改变地址，引用必须从一而终，必须初始化，并且初始化后不能改变，不能指向其它
   - 不存在空应引用，但是存在空指针NULL，相对而言引用更加安全
   - 指针可以有const，可以为空，可以改变指向，因为它是一个变量，如果sizeof得到的结果也不同，自增操作结果也不同，函数参数传递也不同（一个是拷贝，一个是引用传递）

3. **堆和栈的区别**  [**C++/C内存分配方式，堆与栈的区别**](http://note.youdao.com/noteshare?id=bf8357e4c9b0a9728f8642940479dc40&sub=565A97D8C70B48B9A27523FE451D1473)

   1） 堆和栈中的存储内容：栈存局部变量、函数参数等。堆存储使用new、malloc申请的变量等；
   2） 申请方式：栈由系统自动分配；堆需要程序员自己申请，并指明大小，用malloc或new
   3） 申请后系统的响应：栈：只要栈的剩余空间大于所申请，系统将为程序提供内存，否则将报异常提示栈溢出；
   堆：当系统收到程序的申请时，会遍历链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。系统会自动地将多余的那部分重新放入空闲链表中。
   4） 申请大小的限制：
   栈：在Windows下，栈的大小是2MB（编译时就确定的常数），如果申请的空间超过栈的剩余空间，将提示overflow。
   堆：堆是是不连续的内存区域。获得的空间较灵活，也较大。
   5） 申请效率比较：
   栈：由系统自动分配，速度较快。但程序员无法控制
   堆：是由new分配的内存，一般较慢，容易产生内存碎片，但用起来方便
   总结：栈区优势在于处理效率，堆区优势在于灵活

   6）生长方向：

   栈：由高地址向低地址生长

   堆：由低地址到高地址

4. **new和delete是如何实现的，new 与 malloc的异同处**

   new先调用malloc，后调用构造函数，delete先调用析构后调用free；

   malloc/free是C语言库函数，而new/delete是关键字\运算符；

   new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化

   new在申请内存时会自动计算所需字节数，而malloc则需我们自己输入申请内存空间的字节数；malloc需要自己绑定对象类型

   malloc分配的内存不够的时候可以使用realloc扩容，new没有这样的操作

   new内存分配失败抛出bad_malloc，malloc内存分配失败返回NULL值

5. **define/const/inline的区别**

   本质：define只是字符串替换，const参与编译运行，具体的：

   - define不会做类型检查，const拥有类型，会执行相应的类型检查
     . define仅仅是宏替换，不占用内存，而const会占用内存
   - const内存效率更高，编译器通常将const变量保存在符号表中，而不会分配存储空间，这使得它成为一个编译期间的常量，没有存储和读取的操作

   本质：define只是字符串替换，inline由编译器控制，具体的：

   1. 内联函数在编译时展开，而宏是由预处理器对宏进行展开
   2. 内联函数会检查参数类型，宏定义不检查函数参数 ，所以内联函数更安全。
   3. 宏不是函数，而inline函数是函数
   4. 宏在定义时要小心处理宏参数，（一般情况是把参数用括弧括起来）。

6. **volatile关键字**

   访问寄存器要比访问内存要块，因此CPU会优先访问该数据在寄存器中的存储结果，但是内存中的数据可能已经发生了改变，而寄存器中还保留着原来的结果。为了避免这种情况的发生将该变量声明为volatile，告诉CPU每次都从内存去读取数据。

   一个参数可以即是const又是volatile的吗？可以，一个例子是只读状态寄存器，是volatile是因为它可能被意想不到的被改变，是const告诉程序不应该试图去修改他

7. **static关键字的作用**

   - 修饰全局变量
   - 修饰局部变量
   - 修饰全局函数：限制他的作用域只能在本文件之内。
   - 修饰局部函数
   - 修饰类的成员变量、成员函数

8. **extern关键字作用**

   声明一个外部变量

9. **const关键字的作用**

   - const修饰全局变量
   - const修饰局部变量
   - const修饰指针，const int *
   - const修饰指针指向的对象, int * const
   - const修饰引用做形参
   - const修饰成员变量，必须在构造函数列表中初始化
   - const修饰成员函数，说明该函数不应该修改非静态成员，但是这并不是十分可靠的，指针所指的非成员对象值可能会被改变

10. **C++中动态绑定与静态绑定**

   静态类型：对象在声明时采用的类型，在编译期既已确定；

   动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；

   静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；

   动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

11. **静态连接与动态链接的区别**

    - 静态链接
      所谓静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。
    - 动态链接
      所谓动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能。

12. **静态多态和动态多态**

    多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。

13. **多态的实现**

    C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理

14. **多态性与虚函数表**

15. **纯虚函数的作用和实现方式**

16. **STL源码、vector、list、map、set**

17. **深拷贝和浅拷贝的区别**

18. **C++动态内存**

19. **有哪些内存泄漏？如何判断内存泄漏？如何定位内存泄漏？**

20. **C++构造函数能抛异常吗？析构呢？**

21. **字节对齐的原则**

    - 从0位置开始存储；
    - 变量存储的起始位置是该变量大小的整数倍；
    - 结构体总的大小是其最大元素的整数倍，不足的后面要补齐；
    - 结构体中包含结构体，从结构体中最大元素的整数倍开始存；
    - 如果加入pragma pack(n) ，取n和变量自身大小较小的一个。

22. **空结构体的sizeof()返回值**：1

23. **重写、重载与隐藏的区别**

    重载的函数都是在类内的。只有参数类型或者参数个数不同，重载不关心返回值的类型。
    覆盖（重写）派生类中重新定义的函数，其函数名，返回值类型，参数列表都跟基类函数相同，并且基类函数前加了virtual关键字。
    隐藏是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。有两种情况：（1）参数列表不同，不管有无virtual关键字，都是隐藏；（2）参数列表相同，但是无virtual关键字，也是隐藏。

24. **构造函数为什么不能定义为虚函数，析构函数为什么可以**

    - 虚函数的执行依赖于虚函数表。而虚函数表需要在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。
    - 在类的继承中，如果有基类指针指向派生类，那么用基类指针delete时，如果不定义成虚函数，派生类中派生的那部分无法析构。
    - 构造函数不要调用虚函数。在基类构造的时候，虚函数是非虚，不会走到派生类中，既是采用的静态绑定。显然的是：当我们构造一个子类的对象时，先调用基类的构造函数，构造子类中基类部分，子类还没有构造，还没有初始化，如果在基类的构造中调用虚函数，如果可以的话就是调用一个还没有被初始化的对象，那是很危险的，所以C++中是不可以在构造父类对象部分的时候调用子类的虚函数实现。但是不是说你不可以那么写程序，你这么写，编译器也不会报错。只是你如果这么写的话编译器不会给你调用子类的实现，而是还是调用基类的实现。

25. **用过C11吗，知道C11新特性吗**？：lambda **智能指针 移动，auto，范围for**，decltype，array，forward_list，tuple，正则表达式库，随机数库，bitset运算

26. **必须在构造函数初始化式里进行初始化的数据成员有哪些**

    1) 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
    2) 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
    3) 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化

27. **C++四种类型转换**

    static_cast, dynamic_cast, const_cast, reinterpret_cast

    - const_cast用于将const变量转为非const

    - static_cast用的最多，对于各种隐式转换，非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；

    - dynamic_cast用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。

    - reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

      为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

28. **如何让一个类不能实例化？**

    将类定义为抽象基类或者将构造函数声明为private

29. **如何让main函数之前执行函数？**

    1)C++中在main函数之前定义一个全局对象，调用构造函数。
    2) C语言中使用gcc的attribute关键字，声明constructor和destructor。

30. **C++如何创建一个类，使得他只能在堆或者栈上创建？**

    - 只能在堆上生成对象：将析构函数设置为私有。
      原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。
    - 只能在栈上生成对象：将new 和 delete 重载为私有。
      原因：在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象。

31. [**C++命名空间，命名空间的嵌套**](http://www.runoob.com/cplusplus/cpp-namespaces.html)

    可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。

32. [**C++多线程**](http://www.runoob.com/cplusplus/cpp-multithreading.html)

    多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：**基于进程和基于线程**。

    - 基于进程的多任务处理是程序的并发执行。
    - 基于线程的多任务处理是同一程序的片段的并发执行。

33. **explict关键字的作用**

### 数据结构

[1、数组](https://blog.csdn.net/yeyazhishang/article/details/82353846#1数组)

[2、栈](https://blog.csdn.net/yeyazhishang/article/details/82353846#2栈)

[3、队列](https://blog.csdn.net/yeyazhishang/article/details/82353846#3队列)

[4、链表](https://blog.csdn.net/yeyazhishang/article/details/82353846#4链表)

[5、树](https://blog.csdn.net/yeyazhishang/article/details/82353846#5树)

[6、散列表](https://blog.csdn.net/yeyazhishang/article/details/82353846#6散列表)

[7、堆](https://blog.csdn.net/yeyazhishang/article/details/82353846#7堆)

[8、图](https://blog.csdn.net/yeyazhishang/article/details/82353846#8图)

### 操作系统

进程通信方式（linux/windows，每种方式的特点），线程通信（linux/windows），进程与线程区别，页面置换策略（考察置换几次），进/线程状态转换图，进程调度方式，死锁（必要条件，哲学家就餐，银行家，读者写者问题）

Linux方面：IO模型，linux常见命令（grep，awk，sed），文件系统，

1. **进程与线程的区别和联系**：

   **进程**是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。
   **线程**是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。

2. **进程和程序的区别**

   - 进程是动态的，而程序是静态的。
   - 进程有一定的生命期，而程序是指令的集合，本身无“运动”的含义。没有建立进程的程序不能作为1个独立单位得到操作系统的认可。
   - 1个程序可以对应多个进程，但1个进程只能对应1个程序。进程和程序的关系犹如演出和剧本的关系。

3. **一个进程可以创建多少个线程？和什么有关？**

   一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定

4. **什么是孤儿进程和僵尸进程**

   **孤儿进程**：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

   **僵尸进程**：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

5. **一个程序从开始运行到结束的完整过程（**四个过程）：

   预处理（.i，头文件编译进来，宏替换），编译（.s，各种分析后汇编语言），汇编（.o），链接（模块间，动态 静态）

6. **线程池的了解、优点、调度处理方式和保护任务队列的方式**

   池的概念：就是为了重用，减少因为创建销毁带来的性能开销；

   线程池能控制最大的并发数目，提高资源利用率，便于管理和使用

   于是为了避免一个程序需要大量创建线程时的不必要浪费，也就是最好的去避免线程创建与线程销毁的时间浪费，此时线程池就出现了。线程池的实现就是在初始的时候创建一些线程（业界通常认为创建CPU核心数的两倍为最佳，也有说是两倍+1），创建的线程为挂起状态（就绪），当我们有任务要处理的时候，我们就激活一个就绪的线程去完成任务，完成任务后，线程又变为就绪态进行继续等待任务的到来。这样过程使得每个线程一次创建，多次使用，如果你的程序并没有多次任务处理，使得线程池中的线程长时间处于就绪态，此时就建议你直接使用一个线程就好，不必使用线程池

7. 线程池怎么创建？

8. 怎么回收线程

9. 多线程同步（项目中可能会问）

10. mencache

11. 如何保证线程安全？

12. **什么是死锁？死锁产生的原因？**

    **死锁**是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。

    原因：

    - 系统资源的竞争
      系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。
    - 进程运行推进顺序不合适
      进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。

13. **死锁的必要条件**（怎么检测死锁，解决死锁问题）

    （1） 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
    （2） 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
    （3）不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
    （4） 循环等待条件:若干进程间形成首尾相接循环等待资源的关系。

14. **死锁的避免与预防**

    **死锁预防**：通过设置某些限制条件，去破坏死锁的四个条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。

    **死锁避免**：允许前三个必要条件，但通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。

    **死锁检测**：不须实现采取任何限制性措施，而是允许系统在运行过程发生死锁，但可通过系统设置的检测机构及时检测出死锁的发生，并精确地确定于死锁相关的进程和资源，然后采取适当的措施，从系统中将已发生的死锁清除掉。

    **死锁解除**：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。死锁检测盒解除有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。

15. **死锁的解除**

    一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。死锁解除的主要两种方法：

    1. 抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。
    2. 终止（或撤销）进程。终止（或撤销）系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来。

16. **异常和中断的区别**：外部中断，会有中断请求，转去干别的事，然后回到断点；异常是内部的中断，基本上是程序缺陷，很多都是不能预知的

17. **头文件在编译过程中的作用？**

    头文件并不参加链接和编译。编译器第一步要做的就是简单的把头文件在包含它的源文件中展开。不知你是否能理解这句话。也就是头文件里面有什么内容，通通把它移到包含这个头文件的源文件里。（我觉得这是个很重要的概念，可以帮助我们简化理解编译链接的过程，包括理解头文件中定义静态变量或静态函数是怎么回事）。编译器经过这一步转换后剩下什么呢？就是一堆cpp文件了。而头文件已经不再是编译器需要关心的东西了。编译器接下来就要处理这一堆cpp文件了。
    所以第一个阶段是预处理阶段，在正式的编译阶段之前进行。预处理阶段将根据已放置在文件中的预处理指令来修改源文件的内容。如#include指令就是一个预处理指令，它把头文件的内容添加到.cpp文件中。 第二个阶段编译、优化阶段。

18. **一个程序从开始运行到结束的完整过程（四个过程）**

    - 预处理，编译，汇编，链接。
    - 源代码.c 文件先经过预处理器，生成一个中间文件.i 文件，这个阶段有两个作用，一是把include的头文件内容进行替换，二是处理宏定义。
    - .i 文件经过编译生成汇编.s 文件
    - .s 的汇编文件经过汇编器生成.obj 的目标文件
    - .obj 经过链接器和 lib（静态链接库） dll（动态链接库）文件生成 exe 可执行程序

19. **进程间通信的方法？**

    - 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
    - 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
    - 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
    - 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
    - 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
    - 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
    - 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

20. **线程同步方法？**

    - 锁机制
      1. 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。
      2. 读写锁：允许多个线程同时读共享数据，而对写操作互斥。
      3. 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
    - 信号量机制：包括无名线程信号量与有名线程信号量
    - 信号机制：类似于进程间的信号处理。
      线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。

21. **线程创建的方式有几种？**

22. [**进程调度算法？**](https://blog.csdn.net/sayhello_world/article/details/55802928)

    - 先来先去服务
    - 短作业(进程)优先调度算法SJ(P)F
    - 轮转法
    - 多级反馈队列算法

23. [**页面置换方法**](https://www.cnblogs.com/lustar/p/7875705.html)

    - 最优页面置换算法
    - 最近未使用页面置换算法（NRU）
    - 先进先出页面置换算法（FIFO）及其改进
    - 时钟页面置换算法（clock）
    - 最近最少使用页面置换算法（LRU）
    - 工作集算法

24. 布隆过滤器的优点与缺点

25. 布隆过滤器处理大规模问题时的持久化，包括内存大小首先、磁盘换入换出问题

26. 文件读写使用的系统调用

27. 

### 计算机网络

TCP/IP协议及其编程：计算机网络基础，socket编程，其中子网划分，七层协议（例如交换机属于数据链路层一类题目），五层协议，协议名称及其作用，常用端口号，https1.0 1.1特性与区别，三次握手四次挥手（可能出现的服务器攻击），加密（对称，非对称），IO复用等

1. **OSI七层模型**

   物理层、建立、维护、断开物理连接

   数据链路层、建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议），将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。

   网络层、进行逻辑地址寻址，实现不同网络之间的路径选择。协议有：**ICMP IGMP IP（IPV4 IPV6）**

   传输层、定义传输数据的协议端口号，以及流控和差错校验。协议有：**TCP UDP，数据包一旦离开网卡即进入网络传输层**

   会话层、建立、管理、终止会话。（在五层模型里面已经合并到了应用层）**对应主机进程，指本地主机与远程主机正在进行的会话**

   表示层、数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）格式有，**JPEG、ASCll、EBCDIC、加密格式等**

   应用层、网络服务与最终用户的一个接口。协议有：**HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP**

2. **三次握手**

   - 首先Client向Server发送请求报文段，同时同步自己的SYN(x)，Client进入SYN_SENT状态。

   - Server接收到Client的请求报文段，返回CLient自己的seq(y)及ack(x+1)，Server进入SYN_REVD状态。

   - CLinet收到Server的SYN+ACK包，向服务器发送一个序列号seq(x+1)，确认号为ack(y+1)，此包发送完毕，Client和Server进入ESTABLISHED(TCP连接成功)状态，完成三次握手。

     为什么需要三次：防止已失效的报文段出现在本连接中。

3. **四次挥手**

   - 客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）
   - 服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y由服务端随机生成）
   - 服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输到A的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号。（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）
   - 客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h为客户端随机生成）
     至此TCP断开的4次挥手过程完毕

4. **为什么TCP建立连接需要三次握手，而断开连接需要四次挥手？**

   因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

5. **TIME_WAIT的意义，为什么等于2MSL**？

   MSL是**最长报文段寿命**，设置的目的是：

   - 保证A发送的最后一个ACK能够到达B
   - 防止已失效的报文段出现在本连接中

6. **TCP和UDP的区别：**

   TCP---传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，差错控制（检错纠错），流量控制（滑动窗口）等功能，保证数据能顺序地从一端传到另一端。
   UDP---用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，不保证数据按顺序传递，故而传输速度很快。

   ```
   > UDP编程的服务器端一般步骤
   
   1. 创建一个socket，用函数socket()；
   2. 设置socket属性，用函数setsockopt();* 可选
   3. 绑定IP地址、端口等信息到socket上，用函数bind();
   4. 循环接收数据，用函数recvfrom();
   5. 关闭网络连接；
   
   > UDP编程的客户端一般步骤是
   
   1. 创建一个socket，用函数socket()；
   2. 设置socket属性，用函数setsockopt();* 可选
   3. 绑定IP地址、端口等信息到socket上，用函数bind();* 可选
   4. 设置对方的IP地址和端口等属性;
   5. 发送数据，用函数sendto();
   6. 关闭网络连接；
   
   > TCP编程的服务器端一般步骤是
   
   1. 创建一个socket，用函数socket()；
   2. 设置socket属性，用函数setsockopt(); * 可选
   3. 绑定IP地址、端口等信息到socket上，用函数bind();
   4. 开启监听，用函数listen()；
   5. 接收客户端上来的连接，用函数accept()；
   6. 收发数据，用函数send()和recv()，或者read()和write();
   7. 关闭网络连接；
   8. 关闭监听.
   
   > TCP编程的客户端一般步骤是
   
   1. 创建一个socket，用函数socket()；
   2. 设置socket属性，用函数setsockopt();* 可选
   3. 绑定IP地址、端口等信息到socket上，用函数bind();* 可选
   4. 设置要连接的对方的IP地址和端口等属性；
   5. 连接服务器，用函数connect()；
   6. 收发数据，用函数send()和recv()，或者read()和write();
   7. 关闭网络连接.
   ```

7. ==**TCP头部校验的原理，安全吗，可以仿造吗**==

   TCP校验和是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。
   可以仿造。

8. **socket中的close是一次就关闭的吗？半关闭状态是怎么产生的？**

   不是，当A发送给B控制FIN的时候，A到B这个方向的连接就关闭了，这个时候处于半关闭的状态，但是B到A这个方向的连接并没有关闭，因为B要等到将数据全部发送完毕之后才会发送FIN给A。

9. [**TCP拥塞控制**](http://note.youdao.com/noteshare?id=3f6c7666f0396afa8214e45ae059b45d&sub=4919D6D86DF04928956A01DB93369B5F)

   重点掌握**慢开始、拥塞避免、快重传、快恢复。**

10. **TCP流量控制,采用滑动窗口会用什么问题？**

    流量控制是为了让发送方的发送速率不要太快，要让接收方来得及接收。
    Nagle算法：①当发送方首都哦啊哦对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到到达的数据进行缓存。②当到达的数据已达到发送窗口大小的一半或已达到报文段的长度的时候就立即发送一个报文段。
    糊涂窗口综合征：就是由于发送端和接收端上的处理不一致，导致网络上产生很多的小包，结果报文段包含了一个大大的头部，携带数据很少。数据传输效率低。处理方法是等待窗口大小满足一定的条件之后(能够接收一个最大报文，或者缓冲区的一半)，再来发送窗口通告，这样就不会产生小报文。

    > 滑动窗口机制为端到端设备间的数据传输提供了可靠的流量控制机制。然而，它只能在源端设备和目的端设备起作用，当网络中间设备（例如路由器等）发生拥塞时，滑动窗口机制将不起作用。

11. **拥塞控制和流量控制的区别？**

    - 拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不会过载
    - 流量控制往往是点对点通信量的控制，是一个端到端的问题，流量控制要做的是抑制发送端发送数据的速率，以便接收端来得及接收。

12. **TCP怎么保证可靠性？**

    - 应用数据被分割成TCP认为最适合发送的数据块
    - 超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段
    - TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层
    - 校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段
    - TCP的接收端会丢弃重复的数据
    - 流量控制：让发送方的发送速率不要太快，要让接收方来得及接收
    - 拥塞控制：当网络拥塞时，减少数据的发送

13. **TCP滑动窗口协议**

    - “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”
    - “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”

14. **http协议与TCP协议的联系**

    TPC协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。
    Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接。

15. [**http/1.0和http/1.1的区别？**](https://www.jianshu.com/p/95a521b006a8)

    - http1.1提供永久性连接，即1.0使用非持久连接
    - http1.1增加host头
    - http1.1还提供了身份认证，状态管理和cache缓存机制等相关的请求头和响应头。

16. **http请求方法有哪些？get和post的区别**

    - OPTIONS
      返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性
    - HEAD
      向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。
    - GET
      向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url
    - POST
      向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form
    - PUT
      向指定资源位置上传其最新内容
    - DELETE
      请求服务器删除Request-URL所标识的资源
    - TRACE
      回显服务器收到的请求，主要用于测试或诊断
    - CONNECT
      HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

    > (1)根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的
    > (2)根据HTTP规范，POST表示可能修改变服务器上的资源的请求

17. [**http状态码**](https://blog.csdn.net/hliq5399/article/details/51351706)

18. **http和https的区别？由http升级到https需要哪些操作？**

    HTTP 指的是超文本传输协议，https 指的是超文本传输安全协议。HTTPS 就是将 HTTP 中的传输内容进行了加密，然后通过可靠的连接，传输到对方的机器上。加密的协议是 TLS,其前身是 SSL。

19. https具体怎么实现？，怎么确保安全性？

20. **http中浏览器一个URL的流程，这个过程中浏览器做些什么，URL包括哪三个部分？**

    - 浏览器向DNS服务器查找输入URL对应的IP地址。
    - DNS服务器返回网站的IP地址。
    - 浏览器根据IP地址与目标web服务器在80端口上建立TCP连接
    - 浏览器获取请求页面的html代码。      
    - 浏览器在显示窗口内渲染HTML。
    - 窗口关闭时，浏览器终止与服务器的连接。
      URL包括：①协议（或称为服务方式）；②存有该资源的主机IP地址（有时也包括端口号）；③主机资源的具体地址，如目录和文件名等。

21. **http四个会话过程？**

    - 建立tcp连接
    - 发出请求文档
    - 发出响应文档
    - 释放tcp连接
    - 网页解析的过程

22. **网页解析的过程**

    域名解析
    发起TCP的3次握手
    建立TCP连接后发起http请求
    服务器响应http请求
    浏览器解析htm代码,并请求html代码中的资源(如js、css、图片等）
    断开TCP连接
    浏览器对页面进行渲染呈现给用户

23. 在浏览器中输入URL后执行的全部过程（如[www.baidu.com](http://www.baidu.com/)）

24. ==**一个机器能使用的端口号上限是多少？为什么？可以改变吗？如果想要用的端口超过这个限制怎么办？**==

    端口号最多是65535个,端口号2个字节，16位，所以最大表示65535.不能改变

25. DNS解析url过程：

    浏览器搜索自己的DNS缓存（维护一张域名与IP地址的对应表）

    若没有，则搜索操作系统中的DNS缓存（维护一张域名与IP地址的对应表）

    若没有，则搜索操作系统的hosts文件（Windows环境下，维护一张域名与IP地址的对应表，位置一般在 C:\Windows\System32\drivers\etc\hosts）

    若没有，则操作系统将域名发送至 本地域名服务器- -（递归查询方式），本地域名服务器 查询自己的DNS缓存，查找成功则返回结果，否则，（以下是迭代查询方式）

    4.1 本地域名服务器 向根域名服务器（其虽然没有每个域名的具体信息，但存储了负责每个域，如com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，根域名服务器返回com域的顶级域名服务器的地址

    4.2 本地域名服务器 向com域的顶级域名服务器发起请求，返回baidu.com权限域名服务器（权限域名服务器，用来保存该区中的所有主机域名到IP地址的映射）地址

    4.3 本地域名服务器 向baidu.com权限域名服务器发起请求，得到www.baidu.com的IP地址

    本地域名服务器 将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来

    操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来

    至此，浏览器已经得到了域名对应的IP地址

26. **TCP怎么保证可靠性**（面向字节流，超时重传，应答机制，滑动窗口，拥塞控制，校验等）

27. **http协议与TCP联系**

    Http连接是一种短连接，是一种无状态的连接。所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立一个新的连接。

28. **对称密码和非对称密码体系**

    对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。
    非对称加密算法需要两个密钥:公开密钥(publickey)和私有密钥(privatekey)。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密;如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

29. 数字证书的了解（高频）

30. 客户端为什么信任第三方证书？

31. RSA加密算法，MD5原理

32. 单条记录高并发访问的优化

33. [**介绍一下ping的过程，分别用到了那些协议？**](https://blog.csdn.net/fd8559350/article/details/52135571)

    ping用来测试两台主机之间的连通性。ICMP协议

34. [**TCP/IP分片粘包过程**](https://blog.csdn.net/qq513036862/article/details/53640317)

    - 正常情况：如果Socket Client 发送的数据包，在Socket Server端也是一个一个完整接收的，那个就不会出现粘包和分包情况，数据正常读取。
    - 粘包情况：Socket Client发送的数据包，在客户端发送和服务器接收的情况下都有可能发送，因为客户端发送的数据都是发送的一个缓冲buffer，然后由缓冲buffer最后刷到数据链路层的，那么就有可能把数据包2的一部分数据结合数据包1的全部被一起发送出去了，这样在服务器端就有可能出现这样的情况，导致读取的数据包包含了数据包2的一部分数据，这就产生粘包，当然也有可能把数据包1和数据包2全部读取出来。
    - 分包情况：意思就是把数据包2或者数据包1都有可能被分开一部分发送出去，接着发另外的部分，在服务器端有可能一次读取操作只读到一个完整数据包的一部分。
    - 在数据包发送的情况下，有可能后面的数据包分开成2个或者多个，但是最前面的部分包，黏住在前面的一个完整或者部分包的后面，也就是粘包和分包同时产生了。

35. [**有没有抓过TCP包，描述一下**](https://blog.csdn.net/hebbely/article/details/54424823)

36. ==**一个IP配置多个域名，靠什么识别？**==

    主机头

37. 路由器的工作原理和作用，交换机的工作原理和作用

38. 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF和外网网关协议EGP和BGP

39. 路由协议使用的算法

40. 服务器攻击（DDos攻击）

### 数据库

索引作用，应该/不应该创建索引的列，索引底层实现，sql语法，常见引擎特点，事务特点，隔离级别（引擎默认级别），隔离级别的问题，锁等

1.  **关系型和非关系型数据库的区别（各自优点**）

   关系（支持ACID，sql语句，易于维护使用方便，但是维护一致性代价高）：外键关联来建立表和表之间关系；非关系（key-value，海量存储，没有耦合可扩展，读写性能好）：以对象的方式存储（HBASE.MOGODB）

2.  **数据库中事务的ACID**（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）

   一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱

   原子，一致，隔离，持久

3. 有没有设计过表，三种范式

4. **数据库连接池的作用**

    连接复用。通过建立一个数据库连接池以及一套连接使用管理策略，使得一个数据库连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。 getConnection 方法获取连接

5. **数据的锁的种类，加锁的方式：**数据库中一般是悲观锁，认为数据随时会被修改。分为共享s锁（存在死锁，所有s锁的事务都想升级成x锁），排他x锁（写锁，禁止再加任何锁），和更新u锁（允许其他事务读，但是不允许再加u和x锁，当要被更新时升级为x锁）。

   悲观锁按作用范围分为行锁和表锁

   乐观锁：如果没有吞吐量瓶颈还是不用它，可能有风险

6. 

### 设计模式

1. **介绍熟悉的设计模式（单例，简单工厂模式）**

   创建型模式：工厂、抽象工厂、单例；结构性模式：桥接、代理；行为型模式：观察者、命令、策略；J*2EE模式：MVC*

2.  写单例模式（饿汉模式和懒汉模式），线程安全版本

   

### 算法

1. 排序算法，算法的时间复杂度，空间复杂度，是否稳定等

   插入排序、希尔排序、选择排序、冒泡排序、计数排序、**堆排序、快速排序、归并排序**、桶排序、基数排序

2. 查找算法

3. **Top K问题**（可以采取的方法有哪些，各自优点？） 最小堆k；或者最大堆输出k次，直接直选nk

4.  二叉树的**先序、中序、后序遍历**（非递归实现）

5.  **字典树的理解以及在统计上的应用**：根节点不包含字符，另外的节点只包含1个字符，所以1个节点只包含1个字符和几个指针

6. **贪心算法和动态规划的区别**：贪心就是考虑当前，与后面无关；dp就是考虑所有相关情况，把结果保存起来，然后回溯

7. 二叉树

   - 二叉树的非递归前序遍历，中序遍历，后续遍历，层序遍历

   - 二叉树的高度

   - 二叉树的镜像

   - 二叉树的前k大个节点（堆排序）

   - 红黑树和平衡二叉树

     高级数据结构

     - 红黑树
     - [**前缀树**](https://leetcode-cn.com/explore/learn/card/trie/)
     - 字典树

8. 哈希表

   根据设定的哈希函数H（key）和处理冲突方法将一组关键字映象到一个有限的地址区间上的算法。也称为散列算法、杂凑算法。

   **哈希处理冲突的解决方法**

   - 开放定址法、

     从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。
      在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。
      开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。

   - 链地址法（拉链法）、

     链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。

   - 再哈希法、

     就是同时构造多个不同的哈希函数：
      Hi = RHi(key)   i= 1,2,3 ... k;
      当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。

   - 建立公共溢出区等方法。

     将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

算法相关：

判断链表是否有环：快慢指针

输出链表中倒数第k个节点

单链表的倒置



剑指offer   LeetCode   挑一两道题讲思路



### 其他

有没有问题问面试官

观察工作经历，项目经历，排查空档期

对语言的兴趣

代码能力

学习能力，比如看过什么书
